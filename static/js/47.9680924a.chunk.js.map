{"version":3,"file":"static/js/47.9680924a.chunk.js","mappings":"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","sources":["sketches/mazeGenerator/Tile.js","sketches/mazeGenerator/Maze.js","sketches/mazeGenerator/MazeGenerator.jsx"],"sourcesContent":["class Connection {\n    constructor(tileA, tileB) {\n        this.tileA = tileA;\n        this.tileB = tileB;\n        this.isWall = true;\n    }\n}\n\nclass Tile {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.connectionAbove = null;\n        this.connectionRight = null;\n        this.connectionLeft = null;\n        this.connectionBelow = null;\n    }\n\n    setAboveConnection(tile) {\n        this.connectionAbove = new Connection(this, tile);\n    }\n\n    setRightConnection(tile) {\n        this.connectionRight = new Connection(this, tile);\n    }\n\n    setBelowConnection(tile) {\n        this.connectionBelow = new Connection(this, tile);\n    }\n\n    setLeftConnection(tile) {\n        this.connectionLeft = new Connection(this, tile);\n    }\n\n    getTileConnections() {\n        const allConnections = [\n            this.connectionAbove,\n            this.connectionBelow,\n            this.connectionLeft,\n            this.connectionRight,\n        ];\n\n        return allConnections.filter((connection) => {\n            return connection !== null;\n        });\n    }\n\n    getWallConnections() {\n        return this.getTileConnections().filter((connection) => {\n            return connection.isWall;\n        });\n    }\n\n    removeWallBetween(adjacentTile) {\n        const connectionToAdjacentTile = this.getTileConnections().find(\n            (connection) => {\n                return (\n                    connection.tileA === adjacentTile ||\n                    connection.tileB === adjacentTile\n                );\n            }\n        );\n\n        connectionToAdjacentTile.isWall = false;\n    }\n\n    showTile(p, topLeftXPix, topLeftYPix, tileLength) {\n        p.push();\n\n        p.fill(255);\n        p.strokeWeight(1);\n        p.stroke(200);\n        p.rect(topLeftXPix, topLeftYPix, tileLength, tileLength);\n\n        p.pop();\n    }\n\n    showWalls(p, topLeftXPix, topLeftYPix, tileLength) {\n        const wallThickness = tileLength / 8;\n        const topRightXPix = topLeftXPix + tileLength;\n        const topRightYPix = topLeftYPix;\n        const bottomLeftXPix = topLeftXPix;\n        const bottomLeftYPix = topLeftYPix + tileLength;\n        const bottomRightXPix = topLeftXPix + tileLength;\n        const bottomRightYPix = topLeftYPix + tileLength;\n\n        p.push();\n\n        p.strokeWeight(wallThickness);\n        p.stroke(0);\n        p.fill(0);\n\n        if (!this.connectionAbove || this.connectionAbove.isWall) {\n            p.line(topLeftXPix, topLeftYPix, topRightXPix, topRightYPix);\n        }\n\n        if (!this.connectionBelow || this.connectionBelow.isWall) {\n            p.line(\n                bottomLeftXPix,\n                bottomLeftYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        if (!this.connectionLeft || this.connectionLeft.isWall) {\n            p.line(topLeftXPix, topLeftYPix, bottomLeftXPix, bottomLeftYPix);\n        }\n\n        if (!this.connectionRight || this.connectionRight.isWall) {\n            p.line(\n                topRightXPix,\n                topRightYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        p.pop();\n    }\n}\n\nexport { Connection, Tile };\n","import { Tile } from \"./Tile\";\n\nexport default class Maze {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.tiles = [[]];\n        this.visistedTiles = new Set();\n        this.walls = [];\n\n        for (let y = 0; y < height; y++) {\n            this.tiles[y] = [];\n            for (let x = 0; x < width; x++) {\n                this.tiles[y][x] = new Tile(x, y);\n            }\n        }\n\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                this.__addAdjacentTiles(this.tiles[y][x]);\n            }\n        }\n\n        // init maze path\n        const randomX = Math.floor(Math.random() * width);\n        const randomY = Math.floor(Math.random() * height);\n        const start = this.tiles[randomY][randomX];\n        this.visistedTiles.add(start);\n        this.walls = this.walls.concat(start.getWallConnections());\n    }\n\n    __addAdjacentTiles(tile) {\n        const x = tile.x;\n        const y = tile.y;\n\n        if (this.__isValidCoord(x - 1, y)) {\n            tile.setLeftConnection(this.tiles[y][x - 1]);\n        }\n\n        if (this.__isValidCoord(x, y - 1)) {\n            tile.setAboveConnection(this.tiles[y - 1][x]);\n        }\n\n        if (this.__isValidCoord(x + 1, y)) {\n            tile.setRightConnection(this.tiles[y][x + 1]);\n        }\n\n        if (this.__isValidCoord(x, y + 1)) {\n            tile.setBelowConnection(this.tiles[y + 1][x]);\n        }\n    }\n\n    __isValidCoord(x, y) {\n        if (x < 0) {\n            return false;\n        } else if (y < 0) {\n            return false;\n        } else if (x >= this.width) {\n            return false;\n        } else if (y >= this.height) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    __removeTileFromArray(array, tile) {\n        return array.filter((elem) => {\n            const xMatch = elem.x === tile.x;\n            const yMatch = elem.y === tile.y;\n            return !(xMatch && yMatch);\n        });\n    }\n\n    __createFullMazePath() {\n        let visistedTiles = new Set();\n        let walls = [];\n\n        // init\n        const start = this.tiles[0][0];\n        visistedTiles.add(start);\n        walls = walls.concat(start.getWallConnections());\n\n        while (walls.length > 0) {\n            const index = Math.floor(Math.random() * walls.length);\n            const randomWall = walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = visistedTiles.has(tileA);\n            const tileBVisited = visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                walls = walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileB);\n            } else if (!tileAVisited && tileBVisited) {\n                walls = walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileA);\n            }\n\n            walls.splice(index, 1);\n        }\n    }\n\n    __createMazeUntilWallRemoved() {\n        if (this.walls.length > 0) {\n            let wallRemoved = false;\n\n            const index = Math.floor(Math.random() * this.walls.length);\n            const randomWall = this.walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = this.visistedTiles.has(tileA);\n            const tileBVisited = this.visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                this.walls = this.walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileB);\n                wallRemoved = true;\n            } else if (!tileAVisited && tileBVisited) {\n                this.walls = this.walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileA);\n                wallRemoved = true;\n            }\n\n            this.walls.splice(index, 1);\n\n            if (!wallRemoved) {\n                this.__createMazeUntilWallRemoved();\n            }\n        }\n    }\n\n    completed() {\n        return this.walls.length === 0;\n    }\n\n    update() {\n        this.__createMazeUntilWallRemoved();\n    }\n\n    show(p, canvasWidth, canvasHeight) {\n        const maxTileWidth = canvasWidth / this.width;\n        const maxTileHeight = canvasHeight / this.height;\n        const tileLength = Math.min(maxTileWidth, maxTileHeight);\n\n        const xOffset = (canvasWidth - tileLength * this.width) / 2;\n        const yOffset = (canvasHeight - tileLength * this.height) / 2;\n\n        p.push();\n\n        this.__showTiles(p, xOffset, yOffset, tileLength);\n        this.__showWalls(p, xOffset, yOffset, tileLength);\n\n        p.pop();\n    }\n\n    __showTiles(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showTile(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n\n    __showWalls(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showWalls(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n}\n","import React from \"react\";\nimport p5 from \"p5\";\nimport Maze from \"./Maze\";\nimport FullscreenElem from \"../../components/fullscreenElem/FullscreenElem\";\n\nclass MazeGeneratoe extends React.Component {\n    constructor(props) {\n        super(props);\n        this.myRef = React.createRef();\n    }\n\n    sketch = (p) => {\n        const FRAME_RATE = 30;\n        let maze;\n        let framesSinceMazeCompleted = 0;\n\n        const getCanvasHeight = () => {\n            return window.innerHeight;\n        };\n\n        const getCanvasWidth = () => {\n            return window.innerWidth;\n        };\n\n        p.setup = () => {\n            const cnv = p.createCanvas(window.innerWidth, window.innerHeight);\n            cnv.parent(\"canvas\");\n            cnv.style(\"display\", \"block\");\n\n            p.frameRate(FRAME_RATE);\n\n            framesSinceMazeCompleted = 0;\n            maze = new Maze(20, 20);\n        };\n\n        p.draw = () => {\n            p.background(51);\n\n            if (framesSinceMazeCompleted === FRAME_RATE) {\n                framesSinceMazeCompleted = 0;\n                maze = new Maze(20, 20);\n            } else if (maze.completed()) {\n                framesSinceMazeCompleted++;\n            }\n\n            maze.show(p, getCanvasWidth(), getCanvasHeight());\n            maze.update();\n        };\n\n        p.windowResized = () => {\n            p.resizeCanvas(window.innerWidth, window.innerHeight);\n        };\n    };\n\n    componentDidMount() {\n        this.myP5 = new p5(this.sketch, this.myRef.current);\n    }\n\n    componentWillUnmount() {\n        document.getElementById(\"canvas\").replaceChildren();\n    }\n\n    render() {\n        return (\n            <div ref={this.myRef}>\n                <FullscreenElem id='canvas' />\n            </div>\n        );\n    }\n}\nexport default MazeGeneratoe;\n"],"names":["Connection","constructor","tileA","tileB","this","isWall","Tile","x","y","connectionAbove","connectionRight","connectionLeft","connectionBelow","setAboveConnection","tile","setRightConnection","setBelowConnection","setLeftConnection","getTileConnections","filter","connection","getWallConnections","removeWallBetween","adjacentTile","find","showTile","p","topLeftXPix","topLeftYPix","tileLength","push","fill","strokeWeight","stroke","rect","pop","showWalls","wallThickness","topRightXPix","topRightYPix","bottomLeftXPix","bottomLeftYPix","bottomRightXPix","bottomRightYPix","line","Maze","width","height","tiles","visistedTiles","Set","walls","__addAdjacentTiles","randomX","Math","floor","random","randomY","start","add","concat","__isValidCoord","__removeTileFromArray","array","elem","xMatch","yMatch","__createFullMazePath","length","index","randomWall","tileAVisited","has","tileBVisited","splice","__createMazeUntilWallRemoved","wallRemoved","completed","update","show","canvasWidth","canvasHeight","maxTileWidth","maxTileHeight","min","xOffset","yOffset","__showTiles","__showWalls","MazeGeneratoe","React","props","super","sketch","maze","framesSinceMazeCompleted","setup","cnv","createCanvas","window","innerWidth","innerHeight","parent","style","frameRate","draw","background","windowResized","resizeCanvas","myRef","componentDidMount","myP5","p5","current","componentWillUnmount","document","getElementById","replaceChildren","render","_jsx","ref","children","FullscreenElem","id"],"sourceRoot":""}