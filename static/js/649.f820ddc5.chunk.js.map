{"version":3,"file":"static/js/649.f820ddc5.chunk.js","mappings":"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","sources":["sketches/mazeGenerator/Tile.js","sketches/mazeGenerator/Maze.js","sketches/mazeGenerator/MazeGenerator.jsx"],"sourcesContent":["class Connection {\n    constructor(tileA, tileB) {\n        this.tileA = tileA;\n        this.tileB = tileB;\n        this.isWall = true;\n    }\n}\n\nclass Tile {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.connectionAbove = null;\n        this.connectionRight = null;\n        this.connectionLeft = null;\n        this.connectionBelow = null;\n    }\n\n    setAboveConnection(tile) {\n        this.connectionAbove = new Connection(this, tile);\n    }\n\n    setRightConnection(tile) {\n        this.connectionRight = new Connection(this, tile);\n    }\n\n    setBelowConnection(tile) {\n        this.connectionBelow = new Connection(this, tile);\n    }\n\n    setLeftConnection(tile) {\n        this.connectionLeft = new Connection(this, tile);\n    }\n\n    getTileConnections() {\n        const allConnections = [\n            this.connectionAbove,\n            this.connectionBelow,\n            this.connectionLeft,\n            this.connectionRight,\n        ];\n\n        return allConnections.filter((connection) => {\n            return connection !== null;\n        });\n    }\n\n    getWallConnections() {\n        return this.getTileConnections().filter((connection) => {\n            return connection.isWall;\n        });\n    }\n\n    removeWallBetween(adjacentTile) {\n        const connectionToAdjacentTile = this.getTileConnections().find(\n            (connection) => {\n                return (\n                    connection.tileA === adjacentTile ||\n                    connection.tileB === adjacentTile\n                );\n            }\n        );\n\n        connectionToAdjacentTile.isWall = false;\n    }\n\n    showTile(p, topLeftXPix, topLeftYPix, tileLength) {\n        p.push();\n\n        p.fill(255);\n        p.strokeWeight(1);\n        p.stroke(200);\n        p.rect(topLeftXPix, topLeftYPix, tileLength, tileLength);\n\n        p.pop();\n    }\n\n    showWalls(p, topLeftXPix, topLeftYPix, tileLength) {\n        const wallThickness = tileLength / 8;\n        const topRightXPix = topLeftXPix + tileLength;\n        const topRightYPix = topLeftYPix;\n        const bottomLeftXPix = topLeftXPix;\n        const bottomLeftYPix = topLeftYPix + tileLength;\n        const bottomRightXPix = topLeftXPix + tileLength;\n        const bottomRightYPix = topLeftYPix + tileLength;\n\n        p.push();\n\n        p.strokeWeight(wallThickness);\n        p.stroke(0);\n        p.fill(0);\n\n        if (!this.connectionAbove || this.connectionAbove.isWall) {\n            p.line(topLeftXPix, topLeftYPix, topRightXPix, topRightYPix);\n        }\n\n        if (!this.connectionBelow || this.connectionBelow.isWall) {\n            p.line(\n                bottomLeftXPix,\n                bottomLeftYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        if (!this.connectionLeft || this.connectionLeft.isWall) {\n            p.line(topLeftXPix, topLeftYPix, bottomLeftXPix, bottomLeftYPix);\n        }\n\n        if (!this.connectionRight || this.connectionRight.isWall) {\n            p.line(\n                topRightXPix,\n                topRightYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        p.pop();\n    }\n}\n\nexport { Connection, Tile };\n","import { Tile } from \"./Tile\";\n\nexport default class Maze {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.tiles = [[]];\n        this.visistedTiles = new Set();\n        this.walls = [];\n\n        for (let y = 0; y < height; y++) {\n            this.tiles[y] = [];\n            for (let x = 0; x < width; x++) {\n                this.tiles[y][x] = new Tile(x, y);\n            }\n        }\n\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                this.__addAdjacentTiles(this.tiles[y][x]);\n            }\n        }\n\n        // init maze path\n        const randomX = Math.floor(Math.random() * width);\n        const randomY = Math.floor(Math.random() * height);\n        const start = this.tiles[randomY][randomX];\n        this.visistedTiles.add(start);\n        this.walls = this.walls.concat(start.getWallConnections());\n    }\n\n    __addAdjacentTiles(tile) {\n        const x = tile.x;\n        const y = tile.y;\n\n        if (this.__isValidCoord(x - 1, y)) {\n            tile.setLeftConnection(this.tiles[y][x - 1]);\n        }\n\n        if (this.__isValidCoord(x, y - 1)) {\n            tile.setAboveConnection(this.tiles[y - 1][x]);\n        }\n\n        if (this.__isValidCoord(x + 1, y)) {\n            tile.setRightConnection(this.tiles[y][x + 1]);\n        }\n\n        if (this.__isValidCoord(x, y + 1)) {\n            tile.setBelowConnection(this.tiles[y + 1][x]);\n        }\n    }\n\n    __isValidCoord(x, y) {\n        if (x < 0) {\n            return false;\n        } else if (y < 0) {\n            return false;\n        } else if (x >= this.width) {\n            return false;\n        } else if (y >= this.height) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    __removeTileFromArray(array, tile) {\n        return array.filter((elem) => {\n            const xMatch = elem.x === tile.x;\n            const yMatch = elem.y === tile.y;\n            return !(xMatch && yMatch);\n        });\n    }\n\n    __createFullMazePath() {\n        let visistedTiles = new Set();\n        let walls = [];\n\n        // init\n        const start = this.tiles[0][0];\n        visistedTiles.add(start);\n        walls = walls.concat(start.getWallConnections());\n\n        while (walls.length > 0) {\n            const index = Math.floor(Math.random() * walls.length);\n            const randomWall = walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = visistedTiles.has(tileA);\n            const tileBVisited = visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                walls = walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileB);\n            } else if (!tileAVisited && tileBVisited) {\n                walls = walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileA);\n            }\n\n            walls.splice(index, 1);\n        }\n    }\n\n    __createMazeUntilWallRemoved() {\n        if (this.walls.length > 0) {\n            let wallRemoved = false;\n\n            const index = Math.floor(Math.random() * this.walls.length);\n            const randomWall = this.walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = this.visistedTiles.has(tileA);\n            const tileBVisited = this.visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                this.walls = this.walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileB);\n                wallRemoved = true;\n            } else if (!tileAVisited && tileBVisited) {\n                this.walls = this.walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileA);\n                wallRemoved = true;\n            }\n\n            this.walls.splice(index, 1);\n\n            if (!wallRemoved) {\n                this.__createMazeUntilWallRemoved();\n            }\n        }\n    }\n\n    completed() {\n        return this.walls.length === 0;\n    }\n\n    update() {\n        this.__createMazeUntilWallRemoved();\n    }\n\n    show(p, canvasWidth, canvasHeight) {\n        const maxTileWidth = canvasWidth / this.width;\n        const maxTileHeight = canvasHeight / this.height;\n        const tileLength = Math.min(maxTileWidth, maxTileHeight);\n\n        const xOffset = (canvasWidth - tileLength * this.width) / 2;\n        const yOffset = (canvasHeight - tileLength * this.height) / 2;\n\n        p.push();\n\n        this.__showTiles(p, xOffset, yOffset, tileLength);\n        this.__showWalls(p, xOffset, yOffset, tileLength);\n\n        p.pop();\n    }\n\n    __showTiles(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showTile(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n\n    __showWalls(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showWalls(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n}\n","import React from \"react\";\nimport p5 from \"p5\";\nimport Maze from \"./Maze\";\nimport FullscreenElem from \"../../components/fullscreenElem/FullscreenElem\";\n\nclass MazeGeneratoe extends React.Component {\n    constructor(props) {\n        super(props);\n        this.myRef = React.createRef();\n    }\n\n    sketch = (p) => {\n        const FRAME_RATE = 30;\n        let maze;\n        let framesSinceMazeCompleted = 0;\n\n        const getCanvasHeight = () => {\n            return window.innerHeight;\n        };\n\n        const getCanvasWidth = () => {\n            return window.innerWidth;\n        };\n\n        p.setup = () => {\n            const cnv = p.createCanvas(window.innerWidth, window.innerHeight);\n            cnv.parent(\"canvas\");\n            cnv.style(\"display\", \"block\");\n\n            p.frameRate(FRAME_RATE);\n\n            framesSinceMazeCompleted = 0;\n            maze = new Maze(20, 20);\n        };\n\n        p.draw = () => {\n            p.background(51);\n\n            if (framesSinceMazeCompleted === FRAME_RATE) {\n                framesSinceMazeCompleted = 0;\n                maze = new Maze(20, 20);\n            } else if (maze.completed()) {\n                framesSinceMazeCompleted++;\n            }\n\n            maze.show(p, getCanvasWidth(), getCanvasHeight());\n            maze.update();\n        };\n\n        p.windowResized = () => {\n            p.resizeCanvas(window.innerWidth, window.innerHeight);\n        };\n    };\n\n    componentDidMount() {\n        this.myP5 = new p5(this.sketch, this.myRef.current);\n    }\n\n    componentWillUnmount() {\n        document.getElementById(\"canvas\").replaceChildren();\n    }\n\n    render() {\n        return (\n            <div ref={this.myRef}>\n                <FullscreenElem id='canvas' />\n            </div>\n        );\n    }\n}\nexport default MazeGeneratoe;\n"],"names":["Connection","tileA","tileB","this","isWall","Tile","x","y","connectionAbove","connectionRight","connectionLeft","connectionBelow","tile","filter","connection","getTileConnections","adjacentTile","find","p","topLeftXPix","topLeftYPix","tileLength","push","fill","strokeWeight","stroke","rect","pop","wallThickness","topRightXPix","topRightYPix","bottomLeftXPix","bottomLeftYPix","bottomRightXPix","bottomRightYPix","line","Maze","width","height","tiles","visistedTiles","Set","walls","__addAdjacentTiles","randomX","Math","floor","random","randomY","start","add","concat","getWallConnections","__isValidCoord","setLeftConnection","setAboveConnection","setRightConnection","setBelowConnection","array","elem","xMatch","yMatch","length","index","randomWall","tileAVisited","has","tileBVisited","removeWallBetween","splice","wallRemoved","__createMazeUntilWallRemoved","canvasWidth","canvasHeight","maxTileWidth","maxTileHeight","min","xOffset","yOffset","__showTiles","__showWalls","showTile","showWalls","MazeGeneratoe","props","sketch","maze","framesSinceMazeCompleted","setup","cnv","createCanvas","window","innerWidth","innerHeight","parent","style","frameRate","draw","background","completed","show","update","windowResized","resizeCanvas","myRef","React","myP5","p5","current","document","getElementById","replaceChildren","ref","FullscreenElem","id"],"sourceRoot":""}