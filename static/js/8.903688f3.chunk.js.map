{"version":3,"sources":["components/fullscreenElem/FullscreenElem.jsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/superPropBase.js","sketches/hexes/Hex.js","sketches/hexes/HexGrid.js","sketches/hexes/CenterOutHexGrid.js","sketches/hexes/RandomHexGrid.js","sketches/hexes/Hexes.jsx"],"names":["FullscreenElem","toggleCavasFullScreen","canvasElem","document","getElementById","fullscreenElement","exitFullScreen","openFullScreen","elem","requestFullscreen","webkitRequestFullscreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","msExitFullscreen","this","props","onClick","React","Component","target","property","receiver","Reflect","get","base","object","Object","prototype","hasOwnProperty","call","getPrototypeOf","desc","getOwnPropertyDescriptor","value","Hex","p","x","y","maxSideLength","sideLength","growing","growthRate","fillColour","color","outlineColour","pointA","p5","Vector","fromAngle","radians","add","pointB","pointC","pointD","pointE","pointF","push","fill","strokeWeight","stroke","beginShape","vertex","endShape","CLOSE","pop","HexGrid","canvasWidth","canvasHeight","hexSideLength","horizontalHexSpacing","sin","verticleHexSpacing","maxHexXPos","maxHexYPos","hexes","__createHexes","visited","explore","coord","some","element","xDiff","Math","abs","yDiff","surroundingHexes","__getSurroundingHexes","concat","length","forEach","h","hex","update","translate","show","CenterOutHexGrid","lastHueIncrementTime","Date","now","setCenterOutPattern","colorMode","HSL","maxDistFromCenter","dist","hexDistFromCenter","startingSideLength","map","setSideLength","grow","hue","saturation","lightness","setColour","currentTime","RandomHexGrid","setRandomPattern","maxColourVal","random","sat","light","startingSize","shrink","Hexes","sketch","hexGrid","currentPattern","patternRadioGroup","randomPattern","centerOutPattern","getCanvasHeight","window","innerHeight","getCanvasWidth","innerWidth","getSideLength","min","createHexGrid","setup","cnv","createCanvas","parent","style","createRadio","option","selected","angleMode","DEGREES","draw","background","windowResized","resizeCanvas","myRef","createRef","myP5","current","ref","id"],"mappings":"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","file":"static/js/8.903688f3.chunk.js","sourcesContent":["import React from \"react\";\n\n/**\n * A div that when clicked will toggle between fullscreen mode.\n */\nclass FullscreenElem extends React.Component {\n    toggleCavasFullScreen = () => {\n        const canvasElem = document.getElementById(\"canvas\");\n        const currentFullScreenElem = document.fullscreenElement;\n        if (canvasElem === currentFullScreenElem) {\n            this.exitFullScreen(canvasElem);\n        } else {\n            this.openFullScreen(canvasElem);\n        }\n    };\n\n    openFullScreen = (elem) => {\n        if (elem.requestFullscreen) {\n            elem.requestFullscreen();\n        } else if (elem.webkitRequestFullscreen) {\n            /* Safari */\n            elem.webkitRequestFullscreen();\n        } else if (elem.msRequestFullscreen) {\n            /* IE11 */\n            elem.msRequestFullscreen();\n        }\n    };\n\n    exitFullScreen = (elem) => {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n            /* Safari */\n            document.webkitExitFullscreen();\n        } else if (document.msExitFullscreen) {\n            /* IE11 */\n            document.msExitFullscreen();\n        }\n    };\n\n    render() {\n        return <div {...this.props} onClick={this.toggleCavasFullScreen}></div>;\n    }\n}\n\nexport default FullscreenElem;\n","import superPropBase from \"@babel/runtime/helpers/esm/superPropBase\";\nexport default function _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","import p5 from \"p5\";\n\nexport default class Hex {\n    constructor(p, x, y, maxSideLength) {\n        this.p = p;\n        this.x = x;\n        this.y = y;\n        this.maxSideLength = maxSideLength;\n        this.sideLength = maxSideLength;\n        this.growing = false;\n        this.growthRate = 0;\n        this.fillColour = p.color(255, 255, 255);\n        this.outlineColour = p.color(0, 0, 0);\n    }\n\n    setSideLength(sideLength) {\n        this.sideLength = sideLength;\n    }\n\n    grow() {\n        this.growing = true;\n    }\n\n    shrink() {\n        this.growing = false;\n    }\n\n    setColour(fillColour, outlineColour) {\n        this.fillColour = fillColour;\n        this.outlineColour = outlineColour;\n    }\n\n    update() {\n        this.growthRate = 0.1;\n        if (this.sideLength >= this.maxSideLength) {\n            this.growing = false;\n        }\n\n        if (this.sideLength <= 1) {\n            this.growing = true;\n        }\n\n        if (this.growing) {\n            this.sideLength += this.growthRate;\n            if (this.sideLength > this.maxSideLength) {\n                this.sideLength = this.maxSideLength;\n            }\n        } else {\n            this.sideLength -= this.growthRate;\n            if (this.sideLength < 1) {\n                this.sideLength = 1;\n            }\n        }\n    }\n\n    show() {\n        let pointA = p5.Vector.fromAngle(this.p.radians(-90), this.sideLength);\n        pointA.add(this.x, this.y);\n\n        let pointB = p5.Vector.fromAngle(this.p.radians(-30), this.sideLength);\n        pointB.add(this.x, this.y);\n\n        let pointC = p5.Vector.fromAngle(this.p.radians(30), this.sideLength);\n        pointC.add(this.x, this.y);\n\n        let pointD = p5.Vector.fromAngle(this.p.radians(90), this.sideLength);\n        pointD.add(this.x, this.y);\n\n        let pointE = p5.Vector.fromAngle(this.p.radians(150), this.sideLength);\n        pointE.add(this.x, this.y);\n\n        let pointF = p5.Vector.fromAngle(this.p.radians(210), this.sideLength);\n        pointF.add(this.x, this.y);\n\n        this.p.push();\n\n        this.p.fill(this.fillColour);\n        this.p.strokeWeight(1);\n        this.p.stroke(this.outlineColour);\n\n        this.p.beginShape();\n        this.p.vertex(pointA.x, pointA.y);\n        this.p.vertex(pointB.x, pointB.y);\n        this.p.vertex(pointC.x, pointC.y);\n        this.p.vertex(pointD.x, pointD.y);\n        this.p.vertex(pointE.x, pointE.y);\n        this.p.vertex(pointF.x, pointF.y);\n        this.p.endShape(this.p.CLOSE);\n\n        this.p.pop();\n    }\n}\n","import Hex from \"./Hex\";\n\n/**\n * Creates a tiled hex grid with a hex placed in the center of the screen.\n */\nexport default class HexGrid {\n    constructor(p, canvasWidth, canvasHeight, hexSideLength) {\n        this.p = p;\n        this.canvasWidth = canvasWidth;\n        this.canvasHeight = canvasHeight;\n        this.hexSideLength = hexSideLength;\n\n        const horizontalHexSpacing = p.sin(60) * hexSideLength * 2;\n        const verticleHexSpacing = 2 * hexSideLength * 0.75;\n\n        const midWidth = canvasWidth / 2;\n        const midHeight = canvasHeight / 2;\n\n        const maxHexXPos = midWidth + horizontalHexSpacing / 2;\n        const maxHexYPos = midHeight + verticleHexSpacing / 2;\n\n        this.hexes = this.__createHexes(\n            horizontalHexSpacing,\n            verticleHexSpacing,\n            maxHexXPos,\n            maxHexYPos\n        );\n    }\n\n    __createHexes(\n        horizontalHexSpacing,\n        verticleHexSpacing,\n        maxHexXPos,\n        maxHexYPos\n    ) {\n        let hexes = [];\n        let visited = [];\n        let explore = [];\n\n        explore.push({ x: 0, y: 0 });\n\n        while (explore.length > 0) {\n            let coord = explore.pop();\n\n            // Coordinates are floating points, so checking for equality is difficult\n            // and converting to int leads to rounding issues.\n            // So just check there is not a very close coordinate already visited.\n            const matchesThisCoord = (element) => {\n                let xDiff = Math.abs(element.x - coord.x);\n                let yDiff = Math.abs(element.y - coord.y);\n                return xDiff < 2 && yDiff < 2;\n            };\n\n            if (visited.some(matchesThisCoord)) {\n                continue;\n            }\n\n            if (\n                coord.x > maxHexXPos ||\n                coord.x < -maxHexXPos ||\n                coord.y > maxHexYPos ||\n                coord.y < -maxHexYPos\n            ) {\n                continue;\n            }\n\n            visited.push(coord);\n\n            let surroundingHexes = this.__getSurroundingHexes(\n                coord,\n                horizontalHexSpacing,\n                verticleHexSpacing\n            );\n            explore = explore.concat(surroundingHexes);\n        }\n\n        visited.forEach((coord) => {\n            let h = new Hex(this.p, coord.x, coord.y, this.hexSideLength);\n            hexes.push(h);\n        });\n\n        return hexes;\n    }\n\n    __getSurroundingHexes(coord, horizontalHexSpacing, verticleHexSpacing) {\n        let surroundingHexes = [];\n\n        surroundingHexes.push({\n            x: coord.x - horizontalHexSpacing,\n            y: coord.y,\n        });\n        surroundingHexes.push({\n            x: coord.x + horizontalHexSpacing,\n            y: coord.y,\n        });\n        surroundingHexes.push({\n            x: coord.x - horizontalHexSpacing / 2,\n            y: coord.y + verticleHexSpacing,\n        });\n        surroundingHexes.push({\n            x: coord.x + horizontalHexSpacing / 2,\n            y: coord.y + verticleHexSpacing,\n        });\n        surroundingHexes.push({\n            x: coord.x - horizontalHexSpacing / 2,\n            y: coord.y - verticleHexSpacing,\n        });\n        surroundingHexes.push({\n            x: coord.x + horizontalHexSpacing / 2,\n            y: coord.y - verticleHexSpacing,\n        });\n\n        return surroundingHexes;\n    }\n\n    update() {\n        this.hexes.forEach((hex) => {\n            hex.update();\n        });\n    }\n\n    show() {\n        this.p.push();\n        this.p.translate(this.canvasWidth / 2, this.canvasHeight / 2);\n\n        this.hexes.forEach((hex) => {\n            hex.show();\n        });\n\n        this.p.pop();\n    }\n}\n","import HexGrid from \"./HexGrid\";\n\nconst timeBetweenColourChange = (60 / 255) * 1000;\n\nexport default class CenterOutHexGrid extends HexGrid {\n    constructor(p, canvasWidth, canvasHeight, hexSideLength) {\n        super(p, canvasWidth, canvasHeight, hexSideLength);\n        this.lastHueIncrementTime = Date.now();\n        this.setCenterOutPattern();\n    }\n\n    setCenterOutPattern() {\n        this.p.push();\n        this.p.colorMode(this.p.HSL, 255);\n\n        const maxDistFromCenter = this.p.dist(\n            this.canvasWidth / 2,\n            this.canvasHeight / 2,\n            0,\n            0\n        );\n\n        this.hexes.forEach((hex) => {\n            const hexDistFromCenter = this.p.dist(hex.x, hex.y, 0, 0);\n            const startingSideLength = this.p.map(\n                hexDistFromCenter,\n                0,\n                maxDistFromCenter,\n                this.hexSideLength,\n                0\n            );\n            hex.setSideLength(startingSideLength);\n            hex.grow();\n\n            const hue = this.p.map(\n                hexDistFromCenter,\n                0,\n                maxDistFromCenter,\n                180,\n                50\n            );\n            const fillColour = this.p.color(0, 150, hue);\n            const outlineColour = this.p.color(\n                this.p.hue(fillColour),\n                this.p.saturation(fillColour),\n                this.p.lightness(fillColour) / 2\n            );\n            hex.setColour(fillColour, outlineColour);\n        });\n\n        this.p.pop();\n    }\n\n    update() {\n        super.update();\n\n        const currentTime = Date.now();\n        if (currentTime - this.lastHueIncrementTime < timeBetweenColourChange) {\n            return;\n        }\n\n        this.lastHueIncrementTime = currentTime;\n        this.p.push();\n        this.p.colorMode(this.p.HSL, 255);\n\n        this.hexes.forEach((hex) => {\n            const fillColour = this.p.color(\n                this.p.hue(hex.fillColour) + 1,\n                this.p.saturation(hex.fillColour),\n                this.p.lightness(hex.fillColour)\n            );\n            const outlineColour = this.p.color(\n                this.p.hue(hex.outlineColour) + 1,\n                this.p.saturation(hex.outlineColour),\n                this.p.lightness(hex.outlineColour)\n            );\n            hex.setColour(fillColour, outlineColour);\n        });\n\n        this.p.pop();\n    }\n}\n","import HexGrid from \"./HexGrid\";\n\nexport default class RandomHexGrid extends HexGrid {\n    constructor(p, canvasWidth, canvasHeight, hexSideLength) {\n        super(p, canvasWidth, canvasHeight, hexSideLength);\n        this.setRandomPattern();\n    }\n\n    setRandomPattern() {\n        this.p.push();\n        this.p.colorMode(this.p.HSL, 255);\n\n        this.hexes.forEach((hex) => {\n            const maxColourVal = 256;\n            const hue = this.p.random(0, maxColourVal);\n            const sat = this.p.random(maxColourVal * 0.2, maxColourVal * 0.7);\n            const light = this.p.random(maxColourVal * 0.2, maxColourVal * 0.7);\n            const fillColour = this.p.color(hue, sat, light);\n            const outlineColour = this.p.color(\n                this.p.hue(fillColour),\n                this.p.saturation(fillColour),\n                this.p.lightness(fillColour) / 2\n            );\n            hex.setColour(fillColour, outlineColour);\n\n            const startingSize = this.p.random(0, this.hexSideLength);\n            hex.setSideLength(startingSize);\n\n            const isGrowing = this.p.random([true, false]);\n            if (isGrowing) {\n                hex.grow();\n            } else {\n                hex.shrink();\n            }\n        });\n\n        this.p.pop();\n    }\n\n    __;\n}\n","import React from \"react\";\nimport p5 from \"p5\";\nimport CenterOutHexGrid from \"./CenterOutHexGrid\";\nimport HexGrid from \"./HexGrid\";\nimport RandomHexGrid from \"./RandomHexGrid\";\nimport \"./Hexes.scss\";\nimport FullscreenElem from \"../../components/fullscreenElem/FullscreenElem\";\n\nclass Hexes extends React.Component {\n    constructor(props) {\n        super(props);\n        this.myRef = React.createRef();\n    }\n\n    sketch = (p) => {\n        let hexGrid;\n        let currentPattern;\n        let patternRadioGroup;\n\n        const randomPattern = \"Random\";\n        const centerOutPattern = \"CenterOutPattern\";\n\n        const getCanvasHeight = () => {\n            return window.innerHeight;\n        };\n\n        const getCanvasWidth = () => {\n            return window.innerWidth;\n        };\n\n        const getSideLength = () => {\n            let minDim = Math.min(getCanvasHeight(), getCanvasWidth());\n            return 0.05 * minDim;\n        };\n\n        const createHexGrid = () => {\n            switch (currentPattern) {\n                case randomPattern:\n                    return new RandomHexGrid(\n                        p,\n                        getCanvasWidth(),\n                        getCanvasHeight(),\n                        getSideLength()\n                    );\n                case centerOutPattern:\n                    return new CenterOutHexGrid(\n                        p,\n                        getCanvasWidth(),\n                        getCanvasHeight(),\n                        getSideLength()\n                    );\n                default:\n                    return new HexGrid(\n                        p,\n                        getCanvasWidth(),\n                        getCanvasHeight(),\n                        getSideLength()\n                    );\n            }\n        };\n\n        const createControls = () => {\n            patternRadioGroup = p.createRadio();\n            patternRadioGroup.option(randomPattern);\n            patternRadioGroup.option(centerOutPattern);\n            patternRadioGroup.parent(\"radioOptions\");\n\n            patternRadioGroup.selected(randomPattern);\n\n            currentPattern = patternRadioGroup.selected();\n        };\n\n        p.setup = () => {\n            const cnv = p.createCanvas(getCanvasWidth(), getCanvasHeight());\n            cnv.parent(\"canvas\");\n            cnv.style(\"display\", \"block\");\n\n            createControls();\n\n            p.angleMode(p.DEGREES);\n            hexGrid = createHexGrid();\n        };\n\n        p.draw = () => {\n            p.background(51);\n\n            if (patternRadioGroup.selected() !== currentPattern) {\n                currentPattern = patternRadioGroup.selected();\n                hexGrid = createHexGrid();\n            }\n\n            hexGrid.update();\n            hexGrid.show();\n        };\n\n        p.windowResized = () => {\n            p.resizeCanvas(getCanvasWidth(), getCanvasHeight());\n            hexGrid = createHexGrid();\n        };\n    };\n\n    componentDidMount() {\n        this.myP5 = new p5(this.sketch, this.myRef.current);\n    }\n\n    render() {\n        return (\n            <div ref={this.myRef}>\n                <FullscreenElem id='canvas' />\n                <div id='controls'>\n                    <div id='radioOptions'></div>\n                </div>\n            </div>\n        );\n    }\n}\nexport default Hexes;\n"],"sourceRoot":""}