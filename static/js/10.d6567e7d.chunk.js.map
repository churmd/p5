{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","components/fullscreenElem/FullscreenElem.jsx","sketches/mazeGenerator/Tile.js","sketches/mazeGenerator/Maze.js","sketches/mazeGenerator/MazeGenerator.jsx"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","FullscreenElem","toggleCavasFullScreen","canvasElem","document","getElementById","fullscreenElement","exitFullScreen","openFullScreen","elem","requestFullscreen","webkitRequestFullscreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","msExitFullscreen","this","props","onClick","React","Component","Connection","tileA","tileB","isWall","Tile","x","y","connectionAbove","connectionRight","connectionLeft","connectionBelow","tile","connection","getTileConnections","adjacentTile","find","p","topLeftXPix","topLeftYPix","tileLength","fill","strokeWeight","stroke","rect","pop","wallThickness","topRightXPix","topRightYPix","bottomLeftXPix","bottomLeftYPix","bottomRightXPix","bottomRightYPix","line","Maze","width","height","tiles","visistedTiles","Set","walls","__addAdjacentTiles","randomX","Math","floor","random","randomY","start","add","concat","getWallConnections","__isValidCoord","setLeftConnection","setAboveConnection","setRightConnection","setBelowConnection","array","xMatch","yMatch","index","randomWall","tileAVisited","has","tileBVisited","removeWallBetween","splice","wallRemoved","__createMazeUntilWallRemoved","canvasWidth","canvasHeight","maxTileWidth","maxTileHeight","min","xOffset","yOffset","__showTiles","__showWalls","showTile","showWalls","MazeGeneratoe","sketch","maze","framesSinceMazeCompleted","setup","cnv","createCanvas","window","innerWidth","innerHeight","parent","style","frameRate","draw","background","completed","show","update","windowResized","resizeCanvas","myRef","createRef","myP5","p5","current","ref","id"],"mappings":"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","file":"static/js/10.d6567e7d.chunk.js","sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import React from \"react\";\n\n/**\n * A div that when clicked will toggle between fullscreen mode.\n */\nclass FullscreenElem extends React.Component {\n    toggleCavasFullScreen = () => {\n        const canvasElem = document.getElementById(\"canvas\");\n        const currentFullScreenElem = document.fullscreenElement;\n        if (canvasElem === currentFullScreenElem) {\n            this.exitFullScreen(canvasElem);\n        } else {\n            this.openFullScreen(canvasElem);\n        }\n    };\n\n    openFullScreen = (elem) => {\n        if (elem.requestFullscreen) {\n            elem.requestFullscreen();\n        } else if (elem.webkitRequestFullscreen) {\n            /* Safari */\n            elem.webkitRequestFullscreen();\n        } else if (elem.msRequestFullscreen) {\n            /* IE11 */\n            elem.msRequestFullscreen();\n        }\n    };\n\n    exitFullScreen = (elem) => {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n            /* Safari */\n            document.webkitExitFullscreen();\n        } else if (document.msExitFullscreen) {\n            /* IE11 */\n            document.msExitFullscreen();\n        }\n    };\n\n    render() {\n        return <div {...this.props} onClick={this.toggleCavasFullScreen}></div>;\n    }\n}\n\nexport default FullscreenElem;\n","class Connection {\n    constructor(tileA, tileB) {\n        this.tileA = tileA;\n        this.tileB = tileB;\n        this.isWall = true;\n    }\n}\n\nclass Tile {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.connectionAbove = null;\n        this.connectionRight = null;\n        this.connectionLeft = null;\n        this.connectionBelow = null;\n    }\n\n    setAboveConnection(tile) {\n        this.connectionAbove = new Connection(this, tile);\n    }\n\n    setRightConnection(tile) {\n        this.connectionRight = new Connection(this, tile);\n    }\n\n    setBelowConnection(tile) {\n        this.connectionBelow = new Connection(this, tile);\n    }\n\n    setLeftConnection(tile) {\n        this.connectionLeft = new Connection(this, tile);\n    }\n\n    getTileConnections() {\n        const allConnections = [\n            this.connectionAbove,\n            this.connectionBelow,\n            this.connectionLeft,\n            this.connectionRight,\n        ];\n\n        return allConnections.filter((connection) => {\n            return connection !== null;\n        });\n    }\n\n    getWallConnections() {\n        return this.getTileConnections().filter((connection) => {\n            return connection.isWall;\n        });\n    }\n\n    removeWallBetween(adjacentTile) {\n        const connectionToAdjacentTile = this.getTileConnections().find(\n            (connection) => {\n                return (\n                    connection.tileA === adjacentTile ||\n                    connection.tileB === adjacentTile\n                );\n            }\n        );\n\n        connectionToAdjacentTile.isWall = false;\n    }\n\n    showTile(p, topLeftXPix, topLeftYPix, tileLength) {\n        p.push();\n\n        p.fill(255);\n        p.strokeWeight(1);\n        p.stroke(200);\n        p.rect(topLeftXPix, topLeftYPix, tileLength, tileLength);\n\n        p.pop();\n    }\n\n    showWalls(p, topLeftXPix, topLeftYPix, tileLength) {\n        const wallThickness = tileLength / 8;\n        const topRightXPix = topLeftXPix + tileLength;\n        const topRightYPix = topLeftYPix;\n        const bottomLeftXPix = topLeftXPix;\n        const bottomLeftYPix = topLeftYPix + tileLength;\n        const bottomRightXPix = topLeftXPix + tileLength;\n        const bottomRightYPix = topLeftYPix + tileLength;\n\n        p.push();\n\n        p.strokeWeight(wallThickness);\n        p.stroke(0);\n        p.fill(0);\n\n        if (!this.connectionAbove || this.connectionAbove.isWall) {\n            p.line(topLeftXPix, topLeftYPix, topRightXPix, topRightYPix);\n        }\n\n        if (!this.connectionBelow || this.connectionBelow.isWall) {\n            p.line(\n                bottomLeftXPix,\n                bottomLeftYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        if (!this.connectionLeft || this.connectionLeft.isWall) {\n            p.line(topLeftXPix, topLeftYPix, bottomLeftXPix, bottomLeftYPix);\n        }\n\n        if (!this.connectionRight || this.connectionRight.isWall) {\n            p.line(\n                topRightXPix,\n                topRightYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        p.pop();\n    }\n}\n\nexport { Connection, Tile };\n","import { Tile } from \"./Tile\";\n\nexport default class Maze {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.tiles = [[]];\n        this.visistedTiles = new Set();\n        this.walls = [];\n\n        for (let y = 0; y < height; y++) {\n            this.tiles[y] = [];\n            for (let x = 0; x < width; x++) {\n                this.tiles[y][x] = new Tile(x, y);\n            }\n        }\n\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                this.__addAdjacentTiles(this.tiles[y][x]);\n            }\n        }\n\n        // init maze path\n        const randomX = Math.floor(Math.random() * width);\n        const randomY = Math.floor(Math.random() * height);\n        const start = this.tiles[randomY][randomX];\n        this.visistedTiles.add(start);\n        this.walls = this.walls.concat(start.getWallConnections());\n    }\n\n    __addAdjacentTiles(tile) {\n        const x = tile.x;\n        const y = tile.y;\n\n        if (this.__isValidCoord(x - 1, y)) {\n            tile.setLeftConnection(this.tiles[y][x - 1]);\n        }\n\n        if (this.__isValidCoord(x, y - 1)) {\n            tile.setAboveConnection(this.tiles[y - 1][x]);\n        }\n\n        if (this.__isValidCoord(x + 1, y)) {\n            tile.setRightConnection(this.tiles[y][x + 1]);\n        }\n\n        if (this.__isValidCoord(x, y + 1)) {\n            tile.setBelowConnection(this.tiles[y + 1][x]);\n        }\n    }\n\n    __isValidCoord(x, y) {\n        if (x < 0) {\n            return false;\n        } else if (y < 0) {\n            return false;\n        } else if (x >= this.width) {\n            return false;\n        } else if (y >= this.height) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    __removeTileFromArray(array, tile) {\n        return array.filter((elem) => {\n            const xMatch = elem.x === tile.x;\n            const yMatch = elem.y === tile.y;\n            return !(xMatch && yMatch);\n        });\n    }\n\n    __createFullMazePath() {\n        let visistedTiles = new Set();\n        let walls = [];\n\n        // init\n        const start = this.tiles[0][0];\n        visistedTiles.add(start);\n        walls = walls.concat(start.getWallConnections());\n\n        while (walls.length > 0) {\n            const index = Math.floor(Math.random() * walls.length);\n            const randomWall = walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = visistedTiles.has(tileA);\n            const tileBVisited = visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                walls = walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileB);\n            } else if (!tileAVisited && tileBVisited) {\n                walls = walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileA);\n            }\n\n            walls.splice(index, 1);\n        }\n    }\n\n    __createMazeUntilWallRemoved() {\n        if (this.walls.length > 0) {\n            let wallRemoved = false;\n\n            const index = Math.floor(Math.random() * this.walls.length);\n            const randomWall = this.walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = this.visistedTiles.has(tileA);\n            const tileBVisited = this.visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                this.walls = this.walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileB);\n                wallRemoved = true;\n            } else if (!tileAVisited && tileBVisited) {\n                this.walls = this.walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileA);\n                wallRemoved = true;\n            }\n\n            this.walls.splice(index, 1);\n\n            if (!wallRemoved) {\n                this.__createMazeUntilWallRemoved();\n            }\n        }\n    }\n\n    completed() {\n        return this.walls.length === 0;\n    }\n\n    update() {\n        this.__createMazeUntilWallRemoved();\n    }\n\n    show(p, canvasWidth, canvasHeight) {\n        const maxTileWidth = canvasWidth / this.width;\n        const maxTileHeight = canvasHeight / this.height;\n        const tileLength = Math.min(maxTileWidth, maxTileHeight);\n\n        const xOffset = (canvasWidth - tileLength * this.width) / 2;\n        const yOffset = (canvasHeight - tileLength * this.height) / 2;\n\n        p.push();\n\n        this.__showTiles(p, xOffset, yOffset, tileLength);\n        this.__showWalls(p, xOffset, yOffset, tileLength);\n\n        p.pop();\n    }\n\n    __showTiles(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showTile(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n\n    __showWalls(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showWalls(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n}\n","import React from \"react\";\nimport p5 from \"p5\";\nimport Maze from \"./Maze\";\nimport FullscreenElem from \"../../components/fullscreenElem/FullscreenElem\";\n\nclass MazeGeneratoe extends React.Component {\n    constructor(props) {\n        super(props);\n        this.myRef = React.createRef();\n    }\n\n    sketch = (p) => {\n        const FRAME_RATE = 30;\n        let maze;\n        let framesSinceMazeCompleted = 0;\n\n        const getCanvasHeight = () => {\n            return window.innerHeight;\n        };\n\n        const getCanvasWidth = () => {\n            return window.innerWidth;\n        };\n\n        p.setup = () => {\n            const cnv = p.createCanvas(window.innerWidth, window.innerHeight);\n            cnv.parent(\"canvas\");\n            cnv.style(\"display\", \"block\");\n\n            p.frameRate(FRAME_RATE);\n\n            framesSinceMazeCompleted = 0;\n            maze = new Maze(20, 20);\n        };\n\n        p.draw = () => {\n            p.background(51);\n\n            if (framesSinceMazeCompleted === FRAME_RATE) {\n                framesSinceMazeCompleted = 0;\n                maze = new Maze(20, 20);\n            } else if (maze.completed()) {\n                framesSinceMazeCompleted++;\n            }\n\n            maze.show(p, getCanvasWidth(), getCanvasHeight());\n            maze.update();\n        };\n\n        p.windowResized = () => {\n            p.resizeCanvas(window.innerWidth, window.innerHeight);\n        };\n    };\n\n    componentDidMount() {\n        this.myP5 = new p5(this.sketch, this.myRef.current);\n    }\n\n    render() {\n        return (\n            <div ref={this.myRef}>\n                <FullscreenElem id='canvas' />\n            </div>\n        );\n    }\n}\nexport default MazeGeneratoe;\n"],"sourceRoot":""}