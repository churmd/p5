{"version":3,"sources":["components/fullscreenElem/FullscreenElem.jsx","sketches/mazeGenerator/Tile.js","sketches/mazeGenerator/Maze.js","sketches/mazeGenerator/MazeGenerator.jsx"],"names":["FullscreenElem","toggleCavasFullScreen","canvasElem","document","getElementById","fullscreenElement","exitFullScreen","openFullScreen","elem","requestFullscreen","webkitRequestFullscreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","msExitFullscreen","this","props","onClick","React","Component","Connection","tileA","tileB","isWall","Tile","x","y","connectionAbove","connectionRight","connectionLeft","connectionBelow","tile","filter","connection","getTileConnections","adjacentTile","find","p","topLeftXPix","topLeftYPix","tileLength","push","fill","strokeWeight","stroke","rect","pop","wallThickness","topRightXPix","topRightYPix","bottomLeftXPix","bottomLeftYPix","bottomRightXPix","bottomRightYPix","line","Maze","width","height","tiles","visistedTiles","Set","walls","__addAdjacentTiles","randomX","Math","floor","random","randomY","start","add","concat","getWallConnections","__isValidCoord","setLeftConnection","setAboveConnection","setRightConnection","setBelowConnection","array","xMatch","yMatch","length","index","randomWall","tileAVisited","has","tileBVisited","removeWallBetween","splice","wallRemoved","__createMazeUntilWallRemoved","canvasWidth","canvasHeight","maxTileWidth","maxTileHeight","min","xOffset","yOffset","__showTiles","__showWalls","showTile","showWalls","MazeGeneratoe","sketch","maze","framesSinceMazeCompleted","setup","cnv","createCanvas","window","innerWidth","innerHeight","parent","style","frameRate","draw","background","completed","show","update","windowResized","resizeCanvas","myRef","createRef","myP5","p5","current","ref","id"],"mappings":"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","file":"static/js/12.005d1723.chunk.js","sourcesContent":["import React from \"react\";\n\n/**\n * A div that when clicked will toggle between fullscreen mode.\n */\nclass FullscreenElem extends React.Component {\n    toggleCavasFullScreen = () => {\n        const canvasElem = document.getElementById(\"canvas\");\n        const currentFullScreenElem = document.fullscreenElement;\n        if (canvasElem === currentFullScreenElem) {\n            this.exitFullScreen(canvasElem);\n        } else {\n            this.openFullScreen(canvasElem);\n        }\n    };\n\n    openFullScreen = (elem) => {\n        if (elem.requestFullscreen) {\n            elem.requestFullscreen();\n        } else if (elem.webkitRequestFullscreen) {\n            /* Safari */\n            elem.webkitRequestFullscreen();\n        } else if (elem.msRequestFullscreen) {\n            /* IE11 */\n            elem.msRequestFullscreen();\n        }\n    };\n\n    exitFullScreen = (elem) => {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n            /* Safari */\n            document.webkitExitFullscreen();\n        } else if (document.msExitFullscreen) {\n            /* IE11 */\n            document.msExitFullscreen();\n        }\n    };\n\n    render() {\n        return <div {...this.props} onClick={this.toggleCavasFullScreen}></div>;\n    }\n}\n\nexport default FullscreenElem;\n","class Connection {\n    constructor(tileA, tileB) {\n        this.tileA = tileA;\n        this.tileB = tileB;\n        this.isWall = true;\n    }\n}\n\nclass Tile {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.connectionAbove = null;\n        this.connectionRight = null;\n        this.connectionLeft = null;\n        this.connectionBelow = null;\n    }\n\n    setAboveConnection(tile) {\n        this.connectionAbove = new Connection(this, tile);\n    }\n\n    setRightConnection(tile) {\n        this.connectionRight = new Connection(this, tile);\n    }\n\n    setBelowConnection(tile) {\n        this.connectionBelow = new Connection(this, tile);\n    }\n\n    setLeftConnection(tile) {\n        this.connectionLeft = new Connection(this, tile);\n    }\n\n    getTileConnections() {\n        const allConnections = [\n            this.connectionAbove,\n            this.connectionBelow,\n            this.connectionLeft,\n            this.connectionRight,\n        ];\n\n        return allConnections.filter((connection) => {\n            return connection !== null;\n        });\n    }\n\n    getWallConnections() {\n        return this.getTileConnections().filter((connection) => {\n            return connection.isWall;\n        });\n    }\n\n    removeWallBetween(adjacentTile) {\n        const connectionToAdjacentTile = this.getTileConnections().find(\n            (connection) => {\n                return (\n                    connection.tileA === adjacentTile ||\n                    connection.tileB === adjacentTile\n                );\n            }\n        );\n\n        connectionToAdjacentTile.isWall = false;\n    }\n\n    showTile(p, topLeftXPix, topLeftYPix, tileLength) {\n        p.push();\n\n        p.fill(255);\n        p.strokeWeight(1);\n        p.stroke(200);\n        p.rect(topLeftXPix, topLeftYPix, tileLength, tileLength);\n\n        p.pop();\n    }\n\n    showWalls(p, topLeftXPix, topLeftYPix, tileLength) {\n        const wallThickness = tileLength / 8;\n        const topRightXPix = topLeftXPix + tileLength;\n        const topRightYPix = topLeftYPix;\n        const bottomLeftXPix = topLeftXPix;\n        const bottomLeftYPix = topLeftYPix + tileLength;\n        const bottomRightXPix = topLeftXPix + tileLength;\n        const bottomRightYPix = topLeftYPix + tileLength;\n\n        p.push();\n\n        p.strokeWeight(wallThickness);\n        p.stroke(0);\n        p.fill(0);\n\n        if (!this.connectionAbove || this.connectionAbove.isWall) {\n            p.line(topLeftXPix, topLeftYPix, topRightXPix, topRightYPix);\n        }\n\n        if (!this.connectionBelow || this.connectionBelow.isWall) {\n            p.line(\n                bottomLeftXPix,\n                bottomLeftYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        if (!this.connectionLeft || this.connectionLeft.isWall) {\n            p.line(topLeftXPix, topLeftYPix, bottomLeftXPix, bottomLeftYPix);\n        }\n\n        if (!this.connectionRight || this.connectionRight.isWall) {\n            p.line(\n                topRightXPix,\n                topRightYPix,\n                bottomRightXPix,\n                bottomRightYPix\n            );\n        }\n\n        p.pop();\n    }\n}\n\nexport { Connection, Tile };\n","import { Tile } from \"./Tile\";\n\nexport default class Maze {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.tiles = [[]];\n        this.visistedTiles = new Set();\n        this.walls = [];\n\n        for (let y = 0; y < height; y++) {\n            this.tiles[y] = [];\n            for (let x = 0; x < width; x++) {\n                this.tiles[y][x] = new Tile(x, y);\n            }\n        }\n\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                this.__addAdjacentTiles(this.tiles[y][x]);\n            }\n        }\n\n        // init maze path\n        const randomX = Math.floor(Math.random() * width);\n        const randomY = Math.floor(Math.random() * height);\n        const start = this.tiles[randomY][randomX];\n        this.visistedTiles.add(start);\n        this.walls = this.walls.concat(start.getWallConnections());\n    }\n\n    __addAdjacentTiles(tile) {\n        const x = tile.x;\n        const y = tile.y;\n\n        if (this.__isValidCoord(x - 1, y)) {\n            tile.setLeftConnection(this.tiles[y][x - 1]);\n        }\n\n        if (this.__isValidCoord(x, y - 1)) {\n            tile.setAboveConnection(this.tiles[y - 1][x]);\n        }\n\n        if (this.__isValidCoord(x + 1, y)) {\n            tile.setRightConnection(this.tiles[y][x + 1]);\n        }\n\n        if (this.__isValidCoord(x, y + 1)) {\n            tile.setBelowConnection(this.tiles[y + 1][x]);\n        }\n    }\n\n    __isValidCoord(x, y) {\n        if (x < 0) {\n            return false;\n        } else if (y < 0) {\n            return false;\n        } else if (x >= this.width) {\n            return false;\n        } else if (y >= this.height) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    __removeTileFromArray(array, tile) {\n        return array.filter((elem) => {\n            const xMatch = elem.x === tile.x;\n            const yMatch = elem.y === tile.y;\n            return !(xMatch && yMatch);\n        });\n    }\n\n    __createFullMazePath() {\n        let visistedTiles = new Set();\n        let walls = [];\n\n        // init\n        const start = this.tiles[0][0];\n        visistedTiles.add(start);\n        walls = walls.concat(start.getWallConnections());\n\n        while (walls.length > 0) {\n            const index = Math.floor(Math.random() * walls.length);\n            const randomWall = walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = visistedTiles.has(tileA);\n            const tileBVisited = visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                walls = walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileB);\n            } else if (!tileAVisited && tileBVisited) {\n                walls = walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                visistedTiles.add(tileA);\n            }\n\n            walls.splice(index, 1);\n        }\n    }\n\n    __createMazeUntilWallRemoved() {\n        if (this.walls.length > 0) {\n            let wallRemoved = false;\n\n            const index = Math.floor(Math.random() * this.walls.length);\n            const randomWall = this.walls[index];\n\n            const tileA = randomWall.tileA;\n            const tileB = randomWall.tileB;\n            const tileAVisited = this.visistedTiles.has(tileA);\n            const tileBVisited = this.visistedTiles.has(tileB);\n\n            if (tileAVisited && !tileBVisited) {\n                this.walls = this.walls.concat(tileB.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileB);\n                wallRemoved = true;\n            } else if (!tileAVisited && tileBVisited) {\n                this.walls = this.walls.concat(tileA.getWallConnections());\n                tileA.removeWallBetween(tileB);\n                tileB.removeWallBetween(tileA);\n                this.visistedTiles.add(tileA);\n                wallRemoved = true;\n            }\n\n            this.walls.splice(index, 1);\n\n            if (!wallRemoved) {\n                this.__createMazeUntilWallRemoved();\n            }\n        }\n    }\n\n    completed() {\n        return this.walls.length === 0;\n    }\n\n    update() {\n        this.__createMazeUntilWallRemoved();\n    }\n\n    show(p, canvasWidth, canvasHeight) {\n        const maxTileWidth = canvasWidth / this.width;\n        const maxTileHeight = canvasHeight / this.height;\n        const tileLength = Math.min(maxTileWidth, maxTileHeight);\n\n        const xOffset = (canvasWidth - tileLength * this.width) / 2;\n        const yOffset = (canvasHeight - tileLength * this.height) / 2;\n\n        p.push();\n\n        this.__showTiles(p, xOffset, yOffset, tileLength);\n        this.__showWalls(p, xOffset, yOffset, tileLength);\n\n        p.pop();\n    }\n\n    __showTiles(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showTile(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n\n    __showWalls(p, xOffset, yOffset, tileLength) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const topLeftXPix = xOffset + x * tileLength;\n                const topLeftYPix = yOffset + y * tileLength;\n                this.tiles[y][x].showWalls(\n                    p,\n                    topLeftXPix,\n                    topLeftYPix,\n                    tileLength\n                );\n            }\n        }\n    }\n}\n","import React from \"react\";\nimport p5 from \"p5\";\nimport Maze from \"./Maze\";\nimport FullscreenElem from \"../../components/fullscreenElem/FullscreenElem\";\n\nclass MazeGeneratoe extends React.Component {\n    constructor(props) {\n        super(props);\n        this.myRef = React.createRef();\n    }\n\n    sketch = (p) => {\n        const FRAME_RATE = 30;\n        let maze;\n        let framesSinceMazeCompleted = 0;\n\n        const getCanvasHeight = () => {\n            return window.innerHeight;\n        };\n\n        const getCanvasWidth = () => {\n            return window.innerWidth;\n        };\n\n        p.setup = () => {\n            const cnv = p.createCanvas(window.innerWidth, window.innerHeight);\n            cnv.parent(\"canvas\");\n            cnv.style(\"display\", \"block\");\n\n            p.frameRate(FRAME_RATE);\n\n            framesSinceMazeCompleted = 0;\n            maze = new Maze(20, 20);\n        };\n\n        p.draw = () => {\n            p.background(51);\n\n            if (framesSinceMazeCompleted === FRAME_RATE) {\n                framesSinceMazeCompleted = 0;\n                maze = new Maze(20, 20);\n            } else if (maze.completed()) {\n                framesSinceMazeCompleted++;\n            }\n\n            maze.show(p, getCanvasWidth(), getCanvasHeight());\n            maze.update();\n        };\n\n        p.windowResized = () => {\n            p.resizeCanvas(window.innerWidth, window.innerHeight);\n        };\n    };\n\n    componentDidMount() {\n        this.myP5 = new p5(this.sketch, this.myRef.current);\n    }\n\n    render() {\n        return (\n            <div ref={this.myRef}>\n                <FullscreenElem id='canvas' />\n            </div>\n        );\n    }\n}\nexport default MazeGeneratoe;\n"],"sourceRoot":""}